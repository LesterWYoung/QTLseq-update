#! /bin/sh

#This script uses trimmomatic to produce filtered and trimmed files
#This version is for trimming the secondary reference (assuming it's being generated by this pipeline)
#The reads are in ../parental_readfiles/name_R[12].fastq.gz

source ../0.common/common.fnc	#load common variables, including Key1_My_cultivar_sample_name
				# and $Key1_Phred_quality_score_for_my_cultivar (default=30)
Set_MY_CULTIVAR_NAME		# MY_CUTIVAR_NAME=${Key1_My_cultivar_sample_name} in config.txt 

CMD="find ../parental_readfiles/${MY_CULTIVAR_NAME}_R[12].fastq.gz > readfilelist"
#echo ${CMD}
eval ${CMD}

#Set_SRC_READ_PATH_MY_CULTIVAR	# SRC_READ_PATH_MY_CULTIVAR=${Key1_Phred_quality_score_for_my_cultivar} in config.txt
#echo ${SRC_READ_PATH_MY_CULTIVAR}

Set_READ_QVAL_MY_CULTIVAR	# READ_QVAL_MY_CULTIVAR=${Key1_Phred_quality_score_for_my_cultivar} in config.txt
#echo ${READ_QVAL_MY_CULTIVAR}

Set_TRIMMOMATIC			# TRIMMOMATIC=${Key1_Path_to_trimmomatic}
echo ${TRIMMOMATIC}

numfiles=`wc -l < readfilelist`

if [ $numfiles -eq 0 ]      	# if no readfiles are present
	then echo "Parental readfiles are missing. Put them in ../parental_readfiles using name_R[12].fastq.gz format"
	exit 1
fi

if [ $numfiles -gt 2 ]; then	#if more than two readfiles are present, then exit
	echo "There are more than two readfiles in ../parental_readfiles/"
	exit 2
fi

if [ $numfiles -eq 1 ]; then	#if there is only one readfile present, also exit
	echo "Two readfiles are required (one forward and one reverse) in ../parental_readfiles/"
	exit 3
fi

cat readfilelist

while read -r readfile
	do
	readfilename=`cut -f 3 -d "/" <<< $readfile`	#gets file name, removing path
							# echo "filename being used = $readfilename"
							#can maybe change this to $Key1_My_cultivar_sample_name

	parentname=`cut -f 1 -d "_" <<< $readfilename | cut -f 2 -d "/"`	#gets name of cultivar
							# echo "parentname being used = $parentname"

        read_direction=`cut -f 2 -d "_" <<< $readfilename | cut -f 1 -d "."`
        						#searches for "-R[12]." to get read direction
							# echo "read dir = $read_direction"

	if [[ $read_direction == "R1" ]]; then		#if foward readfile, then assign forward variable names
        						#echo "found R1"
		readfileR1=$readfile
		outfileR1paired="secondary_readfiles/$parentname-paired_R1.fastq.gz"
		outfileR1unpaired="secondary_readfiles/$parentname-unpaired_R1.fastq.gz"
							#echo "$readfileR1  $outfileR1paired   $outfileR1unpaired"

	else
        						#echo "found R2"
		readfileR2=$readfile
		outfileR2paired="secondary_readfiles/$parentname-paired_R2.fastq.gz"
		outfileR2unpaired="secondary_readfiles/$parentname-unpaired_R2.fastq.gz"
							# echo "$readfileR2  $outfileR2paired   $outfileR2unpaired"

	fi

done < readfilelist

CMD="${TRIMMOMATIC} PE"
CMD="$CMD $readfileR1 $readfileR2"			#fwd and rev readfiles to be trimmed
CMD="$CMD $outfileR1paired $outfileR1unpaired"		#fwd output reads (paired with rev reads and unpaired)
CMD="$CMD $outfileR2paired $outfileR2unpaired"		#rev output reads (paired with fwd reads and unpaired)
CMD="$CMD LEADING:15 TRAILING:15"			#trims bases from each end if qual<15. Change if desired
CMD="$CMD SLIDINGWINDOW:4:${READ_QVAL}"			# cut if average quality score for sliding window < set value
CMD="$CMD MINLEN:110"					#filter out reads < 110 bp after trimming
CMD="$CMD AVGQUAL:${READ_QVAL}"				#remove read if averagequality is less than set value

echo ${CMD}
eval ${CMD}

